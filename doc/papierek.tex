
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Thin Sectioned Essay
% LaTeX Template
% Version 1.0 (3/8/13)
%
% This template has been downloaded from:
% http://www.LaTeXTemplates.com
%
% Original Author:
% Nicolas Diaz (nsdiaz@uc.cl) with extensive modifications by:
% Vel (vel@latextemplates.com)
%
% License:
% CC BY-NC-SA 3.0 (http://creativecommons.org/licenses/by-nc-sa/3.0/)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------------------------
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass[a4paper, 11pt]{article} % Font size (can be 10pt, 11pt or 12pt) and paper size (remove a4paper for US letter paper)

\usepackage[protrusion=true,expansion=true]{microtype} % Better typography
\usepackage{graphicx} % Required for including pictures
\usepackage{wrapfig} % Allows in-line images
\usepackage{listings}             % Include the listings-package
\usepackage[utf8]{inputenc}
\usepackage{mathpazo} % Use the Palatino font
\usepackage[T1]{fontenc} % Required for accented characters
\linespread{1.05} % Change line spacing here, Palatino benefits from a slight increase by default
\usepackage{color}
\makeatletter
\renewcommand\@biblabel[1]{\textbf{#1.}} % Change the square brackets for each bibliography item from '[1]' to '1.'
\renewcommand{\@listI}{\itemsep=0pt} % Reduce the space between items in the itemize and enumerate environments and the bibliography

\lstset{numbers=left, frame=single,}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}
 
\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\renewcommand{\maketitle}{ % Customize the title - do not edit title and author name here, see the TITLE block below
\begin{flushright} % Right align
{\LARGE\@title} % Increase the font size of the title

\vspace{50pt} % Some vertical space between the title and author name

{\large\@author} % Author name
\\\@date % Date

\vspace{40pt} % Some vertical space between the author block and abstract
\end{flushright}
}

%----------------------------------------------------------------------------------------
%	TITLE
%----------------------------------------------------------------------------------------

\title{\textbf{Przegląd wybranych generatorów liczb pseudolosowych}\\ % Title
i ich analiza pod kątem losowości.} % Subtitle

\author{\textsc{Mateusz Sołtysik, Andrzej Kwak, Wiktor Dyngosz} % Author
\\{Politechnika Wrocławska, \textit{Wydział Podstawowych Problemów Techniki}}} % Institution

\date{\today} % Date

%----------------------------------------------------------------------------------------

\begin{document}

\maketitle % Print the title section

%----------------------------------------------------------------------------------------
%	ABSTRACT AND KEYWORDS
%----------------------------------------------------------------------------------------

%\renewcommand{\abstractname}{Summary} % Uncomment to change the name of the abstract to something else

\begin{abstract}
\end{abstract}

\hspace*{3,6mm}\textit{Keywords: PRGN,  $\chi^2$} 

\vspace{30pt} % Some vertical space between the abstract and first section

\section*{Wstęp}
Pseudo-Random Number Generator (PRNG) – program lub podprogram, który na podstawie niewielkiej ilości informacji (ziarno, ang. seed) generuje deterministyczny, potencjalnie nieskończony, ciąg liczb. Generatory liczb pseudolosowych nie generują ciągów prawdziwie losowych - generator inicjowany ziarnem, które może przyjąć $k$ różnych wartości, jest w stanie wyprodukować co najwyżej $k$ różnych ciągów liczb. Ponieważ rozmiar zmiennych reprezentujących wewnętrzny stan generatora jest ograniczony i może on znajdować się tylko w ograniczonej liczbie stanów, po pewnym czasie generator dokona pełnego cyklu i zacznie generować te same wartości. Teoretyczny limit długości cyklu wyrażony jest przez $2^n$, gdzie $n$ to liczba bitów przeznaczonych na przechowywanie stanu wewnętrznego. W praktyce, większość generatorów ma znacznie krótsze okresy.
\\Pożądane cechy generatorów:
\begin{enumerate}
\item trudne do ustalenia ziarno, choć znany jest ciąg wygenerowanych bitów
\item trudne do ustalenia kolejno generowane bity, choć znany jest ciąg bitów dotychczas wygenerowanych 
\end{enumerate}

%----------------------------------------------------------------------------------------
\section{Opis i analiza algorytmów PRNG}
\subsection*{Informacje wstępne}
Seed (pl. ziarno) - wartość liczbowa, którą inicjujemy generator. Z racji tego, iż PRNG są deterministyczne, wybrany algorytm dla danego seeda generuje identyczne wyjście. 
\begin{lstlisting}[style=mystyle, language=java, frame=single, caption = Przykładowa funkcja generująca seeda]
public static long getSeed() {
      SecureRandom random = new SecureRandom();
      byte seed[] = random.generateSeed(20);
      return Longs.fromByteArray(seed);
}
\end{lstlisting}
\subsection*{Testy chi-kwadrat}
\subsection*{Testy spektralne}
Testy dla każdego algorytmu będą przeprowadzane dla czterech wartości: $10^{1}$, $10^{3}$, $10^{6}$, $10^{9}$, bo zakres 32-bitowej liczby $= \frac{32\log(2)}{\log(10)} \approx 9$.

%----------------------------------------------------------------------------------------
\subsection{Blum Blum Shub}
Algorytm \textit{Blum Blum Shub} został zaproponowany przez Lenore Blum, Manuela Blum'a oraz Michaela Shub'a wiosną, 1986. roku, w pracy: "A Simple Unpredictable Pseudo-Random Number Generator"\footnote{http://epubs.siam.org/doi/abs/10.1137/0215025}. Generator ten jest postaci:
\[ x_{n+1} = (x_{n})^2 \bmod N \]
gdzie $x_{n+1}$ to kolejny stan generatora, $N$ to iloczyn dwóch dużych liczb pierwszych $p$ i $q$ takich, że:
\begin{enumerate}
\item dają w dzieleniu przez 4 resztę 3 ($p\equiv q \equiv 3 \bmod 4$),
\item mają możliwie mały $NWD(\phi(p-1), \phi(q-1))$, co zapewnia długi cykl.
\end{enumerate}
Wynikiem generatora jest kilka ostatnich bitów $x_{n}$.
\begin{lstlisting}[style=mystyle, language=java, frame=single, caption = Generowanie następnej liczby pseudolosowej przez BBS]
private static final int p = 11;
private static final int q = 19;

public static long getRandomNumber() {
    seed = (seed * seed) % (p * q);
    return Math.abs(seed);
}
\end{lstlisting}
Generator ten jest dosyć wolny, ale za to bardzo bezpieczny. Przy odpowiednich założeniach, odróżnienie jego wyników od szumu jest równie trudne co faktoryzacja $N$.
%----------------------------------------------------------------------------------------
\subsection{Liniowy Generator Kongruentny (LCG)}
\begin{lstlisting}[style=mystyle, language=java, frame=single, caption = Generowanie następnej liczby pseudolosowej przez LCG]
private final static long a = 25173;
private final static long b = 13849;
private final static long m = 32768;

public static long getRandomNumber() {
    seed = (a * seed + b) % m;
    return seed;
}
\end{lstlisting}
Addytywny LCG
$xi+1=(a*xi+c) mod m,$
Multiplikatywny LCG
$xi+1 = a * x i mod m$
••Generowane kolejno liczby są z zakresu od 0 do
c-1, stąd po m cyklach obliczeniowych liczby
pseudolosowe zaczynają się powtarzać
Dla pewnych kombinacji parametrów
generowany ciąg jest prawie losowy, dla innych
bardzo szybko staje się okresowy
•Okres obu przedstawionych generatorów zależy
od wartości parametrów równania i opisują
twierdzenia:
%– Jeżeli m = 2k, dla m (wiekszy_równy) 3, to maksymalny okres
generatora liniowego wynosi N = 2k-2, gdy a = 3 mod
8 lub a = 5 mod 8.
– Jeżeli m jest liczbą pierwszą, to generator liniowy
posiada okres maksymalny równy m, gdy a jest pierwiastkiem pierwotnym m
– Pierwiastek pierwotny modulo n to liczba z przedziału
%<1,n−1>, której potęgi modulo n dają wszystkie liczby z $<1,n−1>$.
\\ \\Algorytm doboru współczynników dla generatora LCG
Określamy zakres liczb pseudolosowych
0..xmax dla LCG addytywnego
1..xmax dla LCG multiplikatywnego
Moduł m jest zawsze o 1 większy od maksymalnej liczby
w zakresie, czyli:
m = x max + 1
Przyrost c musi być względnie pierwszy z modułem m
– moduł m można rozłożyć na czynniki pierwsze i jako c wybrane mogą być czynniki nie występujące w rozłożeniu\\
– c może być generowane pseudolosowe, pod warunkiem, że spełnia warunek: gcd(c,m) = 1\\
Mnożnik a dobierany jest tak, aby a - 1 było podzielne przez każdy czynnik pierwszy modułu m\\
– jeśli moduł m dzieli się przez 4, to a - 1 również powinno być podzielne przez 4\\
Przykład generatora LCG (wg D. Knutha)
$xi+1=(a*xi+c) mod m$\\
x0 - ziarno \\
%$a=[\pi*109]$\\
$c=[e*109]$\\
m = 34359738368 = 235
e = 2,7182818284590452353602874713527...
- podstawa logarytmów naturalnych
%----------------------------------------------------------------------------------------
\subsection{Mersenne twister}
\textit{Mersenne twister} został opracowany przez Makoto Matsumoto i Takuji Nishimura w 1997 roku\footnote{http://doi.acm.org/10.1145/272991.272995}. Generator ten dostarcza wysokiej jakości liczby pseudolosowe oraz jest bardzo szybki. Nazwa pochodzi od tego, że na dlugość okresu została wybrana pierwsza liczba Mersenne'a. Algorytm, mimo swoich zalet, nie nadaje się do zastosowań kryptograficznych. Stosunkowo obserwacja niewielkiej liczby iteracji (624) pozwala przewidzieć wszystkie kolejne. Kolejną kwestią jest dlugi czas inicjalizacji algorytmu - w porównaniu do generatora Fibonacciego lub liniowego generatora kongruencyjnego. 
%----------------------------------------------------------------------------------------
\subsection{Generator Park–Miller}
Generator jest odmianą multiplikatywnego liniowego generatora kongruencyjnego, który określamy wzorem:
\[ x_{n+1} = (a * x_{n}) \bmod M \]
gdzie, $x_{n+1}$ to następna liczba pseudolosowa, $a$ - współczynnik generujący kolejną liczbę, $M$ - współczynnik określający zakres generowanych liczb (od $0$ do $M-1$).
\begin{lstlisting}[style=mystyle, language=java, frame=single, caption = Generowanie następnej liczby pseudolosowej przez algorytm Parka-Millera.]
private static final long max = ((long) 2 << 30) - 1;
private static final long a = 16807;

public static long getRandomNumber() {
    seed = (a * seed) % max;
    return seed;
}
\end{lstlisting}
%----------------------------------------------------------------------------------------
\subsection{Xorshift}
Algorytm został zaproponowany przez George Marsaglia\footnote{http://www.jstatsoft.org/v08/i14/paper} w 2003 roku. Liczba $x_{n+1}$ jest generowana poprzez wielokrotną różnicę symetryczną liczb $x_{n}$ i przesuniętej bitowo $x_{n}$. Wykorzystanie funkcji $XOR$ sprawia, że ten algorytm jest niezwykle szybki na współczesnych komputerach.
\\
Algorytm ten jest szybki ale nie niezawodny i z pewnością nie nadaje się do zastosowań kryptograficznych. Jednak, połączenie go z nieliniowym generatorem - jak pierwotnie sugerował autor - prowadzi do jednego z najszybszych generatorów, spełniających silne wymogi testów statystycznych.

\begin{lstlisting}[style=mystyle, language=java, frame=single, caption = Generowanie następnej liczby pseudolosowej przez Xorshift]
public static long getRandomNumber() {
    seed ^= seed >> 12;
    seed ^= seed << 25;
    seed ^= seed >> 27;
    seed = (seed * 2685821657736338717L) % max;
    return Math.abs(seed);
}
\end{lstlisting}
Silnik przeglądarki internetowej Webkit korzysta z tego algorytmu przy wywoływaniu $Math.random()$ w języku JavaScript.
%---------------------------------------------------------------------------------------- %
\subsection{Wichmann and Hill}
Algorytm został zaproponowany przez autorów w 1982 roku. Jego przybliżony okres wynosi $2^{43}$ z tego powodu generator stał się bardzo popularny. Algorytm wykorzystuje kombinacje trzech liniowych generatów kogruentnych (LCG). Na początku inicjalizowane są trzy wartości $I_x$, $I_y$, $ I_z$ które przyjmuja wartości od 1 do 30,000. Następnie wykonywane są następujące operacje: 
$$I_x := 171 \times (I_x \  mod \ 177) - 2 \times (I_x : 177) $$
$$I_y := 172 \times (I_y\ mod\ 176) - 35 \times (I_y : 176) $$
$$ I_z := 170 \times (I_z\ mod \ 178) - 63 \times (I_z : 178)$$
\textbf{if}$I_x < 0$ \textbf{then}
\newline \indent	$I_x := I_x + 30269;$

\noindent \textbf{if}$I_y < 0$ \textbf{then}
\newline \indent	$I_y := I_y + 30307;$

\noindent \textbf{if}$I_z < 0$ \textbf{then}
\newline \indent	$I_z := I_z + 30323;$
\noindent \newline $W := I_x/30269.0 + I_y/30307.0 + I_z/30323.0$
\newline W pracy przy implementacji algorytmu skorzystano z faktu, że WH RNG może być zapisany jako prosty generator kongruentny za pomocą wzoru: 
$$X_{n+1} = 16555425264690 \times X_n\ mod\ 27817185604309 $$
znanego także jako rekursja Zeisela.

\begin{lstlisting}[style=mystyle, language=java, frame=single, caption = Generowanie następnej liczby pseudolosowej przez algorytm Wichmanna-Hilla na podstawie rekursji Zeisela.]
    public long getRandomNumber() {
        seed = (16555425264690L * seed) % 27817185604309L;
        return Math.abs(seed);
    }
\end{lstlisting}

\subsection{Linear feedback shift register}
Linear feedback shift register albo inaczej Rejestr przesuwający z liniowym sprzężeniem zwrotnym to generator, którego bit wejściowy jest funkcją jego poprzedniego stanu. Wartość początkowa rejestru jest jego ziarnem. Następnie ustalone funkcje konkretnych komorek rejestru XORują wynik bitu wychodzącego.
\begin{lstlisting}[style=mystyle, language=java, frame=single, caption = generowanie liczby za pomocą LFSR i przesuwanie komórek.] 
        // wygeneruj liczbe losowa
        int next = 0;
        for (int i = 0; i < M; i++) {
            next |= (bits[i] ? 1 : 0) << i;
        }

        // przesun na zero jeśli liczba ujemna
        if (next < 0) next++;

        // wylicz ostatni rejestr ze stanów określonych rejestrów
        bits[M] = false;
        for (int TAP : TAPS) {
            bits[M] ^= bits[M - TAP];
        }

        // przesuwanie rejestrów
        System.arraycopy(bits, 1, bits, 0, M);

        return Math.abs(next);
    
\end{lstlisting}
Jak widzimy na powyższym listingu liczba generowana jest za pomocą obecnych stanów tablicy. Po wylosowaniu wyrzucany jest ostatni bit i jest xorowany z określonymi przez nas komórkami. Następnie tablica jest przesuwana o 1.
%---------------------------------------------------------------------------------------- %
\subsection{RC4}
RC4 to szyfr strumieniowy, wymyślony przez Rona Rivesta w 1987 roku. Algorytm opiera się na 256 elementowej tablicy i dwóch wskaźnikach. Początkowo tworzona jest permutacja identycznościowa. Następnie w 256 iteracjach tablica jest przetwarzana i mieszana z bajtami klucza.
\begin{lstlisting}[style=mystyle, language=java, frame=single, caption = Inicjalizowanie RC4.]
        String key = Long.toHexString(seed);
        int j = 0;
        for(int i = 0; i < 256; i++){
            j = (j + list.get(i) + (int) key.charAt(i%key.length())) % 256;
            int tmp = list.get(i);
            list.set(i, list.get(j));
            list.set(j, tmp);
\end{lstlisting}
Następnie do generowania kolejnych bitów liczby, ponownie tablica jest przetwarzana.
\begin{lstlisting}[style=mystyle, language=java, frame=single, caption = Generowanie losowego bajtu liczby za pomocą RC4.]
    private String prga(){
        int i,j;
        i = j = 0;
        for(int k = 0; k < 256; k++) {
        	i = (i+1) % 256;
        	j = j + list.get(i) % 256;

        	int tmp = list.get(i);
        	list.set(i, list.get(j));
        	list.set(j, tmp);
        }
        int t = list.get((i+j)%256);
        return Integer.toHexString(list.get(t));
    }
\end{lstlisting}
Dużą zaletą tego szyfru jest jego szybkość. Generator znacznie wydajniej generuje bity od liniowych generatorów. 
%------------------------------------------------------------------- %
\subsection{Multiply-With-Carry}
Algorytm wymyślony przez George'a Marsaglia. Jego głównymi zaletami jest szybkość i wysoki okres (od ok. $2^{60} $ do $2^{2000000}$).
MWC opiera sie na operacji modulo liczby b (zazwyczaj wynosi ona $2^{32}$ dlatego, że w większości komputerów standardowa operacja) 
Generator wymaga podstawy $b$ mnożnika $a$ , zbioru $x$ losowych wartości takich że r zawiera sie w $b$ i początkowego przeniesienia $c < a$. 
Algorytm wygląda następująco:
$$(1)\ t:=a \times x + c $$
$$(2)\ x:= t \ mod \ b $$
$$(3)\ c:= (int)\ t/b$$
Warto zauważyć, że przy arytmetyce $b=2^{32}$ wartość $c$ będzie generowana przez pierwsze 32 bity liczby, natomiast kolejna wartość x przez dolne 32 bity. Mnożnik $a$ jest dobrany w taki sposób aby $ab-1$ i $(ab-1)/2$ były liczbami pierwszymi.
\newline Generator MWC przechodzi testy statystyczne, których generatory LCG nie przechodzą. Przez ten fakt MWC rozważany był jako algorytm kryptograficznie bezpieczny. Jednak badania pokazują, że bity generowane są lekko stronniczo, co przekreśla go w zastosowaniach kryptograficznych.	
\section*{Wnioski}


%----------------------------------------------------------------------------------------
%	BIBLIOGRAPHY
%----------------------------------------------------------------------------------------

%\bibliographystyle{unsrt}

%\bibliography{sample}

%----------------------------------------------------------------------------------------

\end{document}